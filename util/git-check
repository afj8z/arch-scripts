#!/usr/bin/env bash

# --- CONFIGURATION ---
SEARCH_DIR="$HOME"
MY_ID="afj8z"
PATH_MAX_LEN=25  # Adjust this to widen/shrink the path column

# Folders to strictly ignore
IGNORE_LIST=(
    "*/.local/share/Trash"
    "*/node_modules"
    "*/.cache"
    "*/.cargo"
)

# --- VISUAL STYLE ---
# Box characters
H_LINE="─"
V_LINE="│"
X_JOINT="┼" # Used for intersections

# --- COLORS ---
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
GRAY="\033[0;37m"
RESET="\033[0m"

# --- FLAG PARSING ---
SHOW_ONLY_MINE=false
SHOW_DETAILS=false

while [[ "$#" -gt 0 ]]; do
    case $1 in
        -M|--mine)    SHOW_ONLY_MINE=true ;;
        -d|--details) SHOW_DETAILS=true ;;
        -h|--help)    echo "Usage: $0 [--mine | -M] [--details | -d]"; exit 0 ;;
        *) echo "Unknown parameter passed: $1"; exit 1 ;;
    esac
    shift
done

# --- FUNCTION: SMART SHORTEN PATH ---
smart_shorten() {
    local path="$1"
    local max="$2"
    if [ ${#path} -le $max ]; then echo "$path"; return; fi

    IFS='/' read -ra PARTS <<< "$path"
    local count=${#PARTS[@]}
    
    for (( i=0; i<$count-1; i++ )); do
        local part="${PARTS[$i]}"
        if [[ "${part:0:1}" == "." ]]; then PARTS[$i]="${part:0:2}"; else PARTS[$i]="${part:0:1}"; fi
        local new_path=$(IFS=/; echo "${PARTS[*]}")
        if [ ${#new_path} -le $max ]; then echo "$new_path"; return; fi
    done
    IFS=/; echo "${PARTS[*]}"
}

# --- FUNCTION: REPEAT CHAR ---
# Usage: rep "─" 10
rep() {
    local char=$1
    local count=$2
    printf "%0.s${char}" $(seq 1 $count)
}

# --- HEADER GENERATION ---
W_OWNER=10
W_PATH=$PATH_MAX_LEN
W_STATE=20
W_SYNC=12

# Construct the Separator Line
# Structure: [OWNER] [JOINT] [PATH] [JOINT] [STATE] [JOINT] [SYNC]
SEP_LINE="$(rep $H_LINE $((W_OWNER+1)))${X_JOINT}$(rep $H_LINE $((W_PATH+2)))${X_JOINT}$(rep $H_LINE $((W_STATE+2)))${X_JOINT}$(rep $H_LINE $W_SYNC)"

echo "Scanning $SEARCH_DIR for repositories..."
if [ "$SHOW_ONLY_MINE" = true ]; then echo "(Filtering for owner: $MY_ID)"; fi

# Print Table Header
printf "%-${W_OWNER}s %s %-${W_PATH}s %s %-${W_STATE}s %s %s\n" \
    "OWNER" "$V_LINE" "PATH" "$V_LINE" "STATE" "$V_LINE" "SYNC"

echo "$SEP_LINE"

# --- BUILD FIND COMMAND ---
FIND_CMD=(find "$SEARCH_DIR" -type d)
if [ ${#IGNORE_LIST[@]} -gt 0 ]; then
    FIND_CMD+=(\()
    for ignore in "${IGNORE_LIST[@]}"; do
        [[ "$ignore" != "${IGNORE_LIST[0]}" ]] && FIND_CMD+=(-o)
        FIND_CMD+=(-path "$ignore")
    done
    FIND_CMD+=(\) -prune -o)
fi
FIND_CMD+=(-name ".git" -type d -print)

# --- MAIN LOOP ---
"${FIND_CMD[@]}" | while read gitdir; do
    repo_root=$(dirname "$gitdir")
    if ! cd "$repo_root"; then continue; fi

    # 1. OWNER
    remote_url=$(git config --get remote.origin.url)
    if [[ "$remote_url" == *"$MY_ID"* ]]; then
        owner_txt="[MINE]"
        owner_col="$BLUE"
        is_mine=true
    else
        owner_txt="[EXT ]"
        owner_col="$GRAY"
        is_mine=false
    fi

    if [ "$SHOW_ONLY_MINE" = true ] && [ "$is_mine" = false ]; then continue; fi

    # 2. STATUS
    git_status=$(git status --porcelain 2>/dev/null)
    if [[ -z "$git_status" ]]; then
        state_txt="CLEAN"
        state_col="$GREEN"
    else
        state_col="$RED"
        if [ "$SHOW_DETAILS" = true ]; then
            cnt_mod=$(echo "$git_status" | grep -c "^ .") 
            cnt_stg=$(echo "$git_status" | grep -c "^[^ ?]")
            cnt_unt=$(echo "$git_status" | grep -c "^??")
            state_txt=""
            [[ $cnt_mod -gt 0 ]] && state_txt="${state_txt}M:${cnt_mod} "
            [[ $cnt_stg -gt 0 ]] && state_txt="${state_txt}S:${cnt_stg} "
            [[ $cnt_unt -gt 0 ]] && state_txt="${state_txt}?:${cnt_unt}"
        else
            state_txt="DIRTY"
        fi
    fi

    # 3. SYNC
    sync_txt=""
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    
    if [ -z "$current_branch" ]; then
        sync_txt="${YELLOW}(Detached)${RESET}"
    elif ! git rev-parse --abbrev-ref @{u} >/dev/null 2>&1; then
        sync_txt="${GRAY}(No Upstream)${RESET}"
    else
        commits_diff=$(git rev-list --left-right --count HEAD...@{u} 2>/dev/null)
        if [ $? -eq 0 ]; then
            ahead=$(echo "$commits_diff" | cut -f1)
            behind=$(echo "$commits_diff" | cut -f2)
            if [ "$ahead" -gt 0 ]; then sync_txt="$sync_txt${YELLOW}↑${ahead}${RESET} "; fi
            if [ "$behind" -gt 0 ]; then sync_txt="$sync_txt${RED}↓${behind}${RESET} "; fi
            if [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ]; then sync_txt="${GREEN}✔${RESET}"; fi
        else
            sync_txt="${RED}Error${RESET}"
        fi
    fi

    # 4. PRINT ROW
    if [[ "$is_mine" == true ]] || [[ "$state_txt" != "CLEAN" ]] || [[ "$sync_txt" == *"↑"* ]] || [[ "$sync_txt" == *"↓"* ]]; then
        
        display_path=$(smart_shorten "${repo_root#"$SEARCH_DIR"/}" "$PATH_MAX_LEN")

        # Format: Color+Text+Reset | Path | Color+Text+Reset | Sync
        printf "%b%-10s%b %s %-${PATH_MAX_LEN}s %s %b%-20s%b %s %b\n" \
            "$owner_col" "$owner_txt" "$RESET" "$V_LINE" \
            "$display_path" "$V_LINE" \
            "$state_col" "$state_txt" "$RESET" "$V_LINE" \
            "$sync_txt"
    fi
done
